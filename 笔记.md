运行 DEBUG=locallibrary:* npm start  或者 cd bin  node www
导航至 http://localhost:3000/ ，就可以访问该应用

开启debug  就不用每次改变都重启 服务器了

nodemon 自动化工具  全局安装
npm install -g nodemon

还可以把它作为开发依赖  安装在本地
npm install --save-dev nodemon

项目的 package.json 文件将自动添加一个新的属性：

  "devDependencies": {
    "nodemon": "^1.18.9"
  }

注意：如果没有全局安装 就无法从命令行启动它 
找到 package.json 的 scripts 部分。在 "start" 一行的末尾添加逗号，并在新的一行中添加 "devstart"，如下所示：

  "scripts": {
    "start": "node ./bin/www",
    "devstart": "nodemon ./bin/www"
  },

使用 devstart 启动命令行
DEBUG=locallibrary:* npm run devstart

cookie-parser：用于解析 cookie 头来填充 req.cookies（提供了访问 cookie 信息的便捷方法）。
debug：一个小型 node 调试程序，仿照 node 核心的调试技术建立。
http-errors：处理错误中间件。
morgan：node 专用 HTTP 请求记录器中间件。


express 教程3： 使用数据库


与数据库最好的交互方式
使用数据库的原生查询语言（例如SQL）
使用对象数据模型（Object Data Model，简称 ODM）或对象关系模型（Object Relational Model，简称 ORM）。 
ODM / ORM 能将网站中的数据表示为 JavaScript 对象，
然后将它们映射到底层数据库。一些 ORM 只适用某些特定数据库，还有一些是普遍适用的。

使用 ORM 的好处是：程序员可以继续用 JavaScript 对象的思维而不用转向数据库语义的思维。 
在（同一个或不同网站）使用不同数据库时尤为明显。
使用 ORM 还可以更方便地对数据进行验证和检查。


Mongoose：一款为异步工作环境设计的 MongoDB 对象建模工具

Mongoose 作为 MongoDB（面向文档数据模型的开源 NoSQL 数据库）的前端。
MongoDB 数据库里，“集合”中的“文档” 类似于 关系数据库里“表”中的“行”。


##设计locallibrary  模型

#本网站需要存储什么数据？不同对象之间的关系是怎么的？

_图书馆需要存储藏书信息（书名、摘要、作者、种类、ISBN），
藏书副本信息（全站唯一 ID，借出状态，等）。还可能需要存储作者姓名之外的更多信息，
以及多个作者的信息。
还希望数据库内容能够根据书名、作者姓名、种类和编目进行排序。_

也许还希望使用模型而不是站点代码来表示选项表（比如下拉列表），
在选项无法预知或可能更改时更推荐模型方式。
很明显，藏书类型（比如科幻小说、法语诗歌，等）就是这种情况。

##Mongoose 入门
安装
npm install mongoose



**架设MongoDB数据库**

​	mLab云数据库  适合进行开发和原型设计 

​	

### [图书种类模型（Genre）——挑战自我！](https://developer.mozilla.org/zh-CN/docs/Learn/Server-side/Express_Nodejs/mongoose#图书种类模型（genre）——挑战自我！)

打开 **./models/genre.js** 文件，并创建一个模式来存储 `Genre`（书本的类别，例如它是小说类还是纪实类，是爱情题材还是军事史题材，等）。

与之前模型的定义方式相似：

- 该模型应该有一个 `String` 模式类型，命名为 `name` ，用来描述图书种类。
- `name` 字段应该是必需的，并且有 3 到 100 个字符。
- 声明一个 [虚拟属性](https://developer.mozilla.org/zh-CN/docs/Learn/Server-side/Express_Nodejs/mongoose#虚拟属性)，命名为 `url`，返回图书类型 URL。
- 导出模型。

**_路由和控制器_**
模型已经创建，现在要创建的主要是：

路由：把需要支持的请求（以及请求 URL 中包含的任何信息）转发到适当的控制器函数。
控制器：从模型中获取请求的数据，创建一个 HTML 页面显示出数据，
并将页面返回给用户，以便在浏览器中查看。
视图（模板）：供控制器用来渲染数据。



# **本地图书基础模板**

​			创建一个基础的模板pug  模板会有一个侧边栏  用于链接到 各个页面

​		呈现创建书本、种类、作者    以及一个主要内容区域  在每个页面中进行覆写。



进入到 controllers  对 bookController。js  更改index  引入 async

async.parallel（）  方法传递一个对象，其中包含用于获取每个模型计数的函数。这些函数都是在同一时间开始的。当这些函数全部完成时，最终回调将与结果参数中的计数（或错误）一起被调用。





弄完 index.pug  后

# 书本列表页面

​	实体书本列表页面.  这个页面需要呈现数据库中所有书本的列表，包括每本书的作者、标题、  标题是一个a标签（超链接）  链接到书本详细内容页面



## 控制器

​	在打开 **/controllers/bookController.js**. 找到导出的 `book_list()` 控制器方法

使用 模型find（）函数  返回所有book对象  选择仅返回标题 title  和作者 author

这里我们还调用`Book`上的`populate()` ，指定作者`author`字段 — 这将用完整的作者信息，替换存储的书本作者 id。





# **书本实例列表页面**

​	实现图书馆所有书本的实例  bookinstance 列表页面

​	*这个页面包含包含与每个bookinstance（链接带其它详细信息页面）关联的书本Book标题*，*以及bookinstance模型中的其它信息，包括每个副本的状态，印记和唯一ID。唯一文字  应该链接到bookinstance详细信息页面*。



来到 BookInstance.js  控制器中

​	需要 获取所有书本实例的列表  填充关联的书本信息  最后将列表传递给模板进行呈现。



启动项目	cd bin  && node www    访问[书本实例列表](http://localhost:3000/catalog/bookinstances)





# **使用moment做日期格式化**

​	在上一个 所有书籍实例中的时间 呈现不好看  	以更友好的格式显示due_date字段	december 6th,2016  

​	在bookinstance模型中，创建一个返回格式化日期的虚拟属性   使用moment 来做实际的格式化   这是一个js日期库，用于验证、解析、操作和格式化日期。



​	



# **作者清单页面、分类清单页面、自我挑战**

者列表页面，需要呈现数据库中所有作者的列表，有每位作者的名字，并连结到作者详细内容页面。出生与死亡日期应该在名字后面，并且在同一列。

## [控制器](https://developer.mozilla.org/zh-CN/docs/learn/Server-side/Express_Nodejs/Displaying_data/Author_list_page#控制器)

作者列表控制器函数，需要获取所有作者实例的列表，然后将这些实例传递给模板进行渲染。

​	种类实例  完成 genre_list.pug



# **种类细节页面**

​	*种类细节页面，需要利用_id字段值（自动生成），以呈现特定种类实例的信息*

​	此页面呈现种类名称、各个种类的所有书本列表（<u>*每本书连接到书本的细节页面*</u>）。

## 控制器

​	genreController.js   引入 async  Book 模组









# **书本详细信息页面**

​	<u>*书本细节页面需要呈现一本指定书本（book）的信息，使用他的_id字段值（自动产生）做为识别，接着是图书馆中书本实例（BookInstance）的信息。*</u>



## 控制器  

​	bookController.js   在book_detail()  控制器方法下   





# **作者细节页面**

​	*作者细节页面 需要指定作者Author的信息，使用_id 字段值（自动产生）识别，接着是这个作者的所有书本物件Book的列表*

​	

控制器  authorController.js   

 async.parallel()  用平行的方式  查询作者Author 和相应的书本实例

并附加上绘制本页面的回调  如果两个要求都成功完成 就运行回调





# **书本实例细节页面、与自我挑战**

### 	*书本实例细节页面*

​		BookInstance细节页面，需要呈现每一个BookInstance的信息，用_id字段值

（自动产生）做识别。它包含Book名称（也是一个连结，连到书本细节页面），接着是记录中的其它信息。



​	控制器  bookinstanceController.js  找到  bookinstance_detail()  方法





# **自我挑战**



​	改善作者生命周期日期的显示外观信息  December 6th,2016.







# **呈现图书馆数据**

​	显示本地图书馆网站的书本与其它资料   

​	这些网页将包含一个主页，显示我们拥有的每个模型的记录数，以及所有模型的清单和详细信息页面   获得数据库获取记录，以及使用模板的实战经验



## 	**使用async进行非同步流控制**

​		有些本地图书馆的控制器代码  会依赖多重非同步要求的结果，可能会需要以某种特定次序运行，或者以平行的方式运行。

​	可以管理异步行为和留控制  包括js   如Promises

- `async.parallel()` 执行必须并行执行的任何操作。
- `async.series()` 用于当需要确保异步操作是序列执行的。
- `async.waterfall()` 用于必须序列运行的操作，每个操作取决于前面操作的结果。



### 	序列的非同步操作

​		*async.series()  方法用于按顺序运行多个异步操作，后续函数不依赖于先前函数的输出。它本质上是声明的，并且行为与async.parallel()相同*



### 	**依赖序列的非同步操作**

​	方法async.waterfall()  用于每个操作依赖于前一个操作的结果时，依次运行多个异步操作。





# **使用表单**

​	如何使用express并且结合pug来实现html表单  并且如何从数据库中创建，更新和删除文档。

​	*表单和服务器交互数据也相对安全，因为它使用POST请求发送数据，保护不受跨站点请求伪造攻击（cross-site request forgery）的威胁。*



我们将扩展  本地图书网站  ，允许用户创建，编辑和删除图书馆中的项目。

路由

​	第一个（`GET`）路由，用于显示用于创建对象的新空表单。第二个路由（`POST`），用于验证用户输入的数据，然后保存信息，并重定向到详细信息页面（如果数据有效），或重新显示有错误的表单（如果数据无效）。







# **创建种类表单**

​	创建Genre物件		需要设置路由、控制器和视图

# **创建作者表单**

​	*创建作者对象Author定义一个页面*

### 	**自我挑战：加入死亡日期**

​		输入字段 `date_of_death` 。依照跟生日表单同样的模式，创建此字段！





# **创建书本表单**

​	显示如何定义页面、表单以创建Book对象 

​		需要在我们的书本表单中，获取并显示可用的作者和种类记录





# **创建书本实例表单**

​	如何定义一个页面/表单，以创建BookInstance 物件





# **删除作者表单**



​	此子文档显示，如何定义页面以删除Author对象

只允许删除“未被其它对象引用”的对象

（在这种情况下，这意味着如果作者`Author`被一本书`Book`引用，我们将不允许删除作者）。

表单需要在删除作者之前，先确认没有关联的书籍。如果存在关联的书籍，则应显示他们，并说明在删除Author对象之前，必须删除他们。



# **更新书本表单**

​	如何定义一个页面，以及更新书本（book）对象。当更新一本书的时候，表单处理更像是创建一本书，除了必须将表单填进GET路由，并附加上来自数据库的值。



# **项目的部署**



​	在敲完以上代码之后  就得部署项目了   

不得说   部署是最后一个环节   也是最令人期待的

我已有一台云服务  Ubuntu  server  

在服务器上安装 宝塔面板

​	*安装基础包*

​		sudo apt-get install build-essential

​	*安装yum*

​		sudo apt-get install yum

先切换到root 用户下 （保证有权限）

wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh && sudo bash install.sh ed8484bec
